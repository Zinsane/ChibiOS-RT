/*
    ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
                 2011,2012 Giovanni Di Sirio.

    This file is part of ChibiOS/RT.

    ChibiOS/RT is free software; you rng redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    ChibiOS/RT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

                                      ---

    A special exception to the GPL can be applied should you wish to distribute
    a combined work that includes ChibiOS/RT, without being obliged to provide
    the source code for any proprietary components. See the file exception.txt
    for full details of how and when the exception can be applied.
*/

/**
 * @file    rng.c
 * @brief   RNG Driver code.
 *
 * @addtogroup RNG
 * @{
 */

#include "ch.h"
#include "hal.h"

#if HAL_USE_RNG || defined(__DOXYGEN__)

/*===========================================================================*/
/* Driver local definitions.                                                 */
/*===========================================================================*/

/*===========================================================================*/
/* Driver exported variables.                                                */
/*===========================================================================*/

/*===========================================================================*/
/* Driver local variables.                                                   */
/*===========================================================================*/

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

/*===========================================================================*/
/* Driver exported functions.                                                */
/*===========================================================================*/

/**
 * @brief   RNG Driver initialization.
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void rngInit(void) {

  rng_lld_init();
}

/**
 * @brief   Initializes the standard part of a @p RNGDriver structure.
 *
 * @param[out] rngp     pointer to the @p RNGDriver object
 *
 * @init
 */
void rngObjectInit(RNGDriver *rngp) {

  rngp->state    = RNG_STOP;
  chSemInit(&rngp->drdy_sem, 0);
  chMtxInit(&rngp->gen_mtx);
  chEvtInit(&rngp->drdy_event);
  chEvtInit(&rngp->error_event);
  rngp->status = 0;
}

/**
 * @brief   Configures and activates the RNG peripheral.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 *
 * @api
 */
void rngStart(RNGDriver *rngp) {

  chDbgCheck(rngp != NULL, "rngStart");

  chSysLock();
  chDbgAssert((rngp->state == RNG_STOP),
              "rngStart(), #1", "invalid state");
  if (rngp->state == RNG_STOP) {
    rng_lld_start(rngp);
    rngp->state = RNG_READY;
  }
  chSysUnlock();
}

/**
 * @brief   Deactivates the RNG peripheral.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 *
 * @api
 */
void rngStop(RNGDriver *rngp) {

  chDbgCheck(rngp != NULL, "rngStop");

  chSysLock();
  chDbgAssert((rngp->state == RNG_STOP) || (rngp->state == RNG_READY),
              "rngStop(), #1", "invalid state");
  rng_lld_stop(rngp);
  chSemResetI(&rngp->drdy_sem, 0);
  chSchRescheduleS();
  rngp->state  = RNG_STOP;
  rngp->status = 0;
  chSysUnlock();
}

/**
 * @brief   Returns the current status mask and clears it.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 * @return              The status flags mask.
 *
 * @api
 */
rngstatus_t rngGetAndClearFlags(RNGDriver *rngp) {
  rngstatus_t status;

  chSysLock();
  status = rngp->status;
  rngp->status = 0;
  chSysUnlock();
  return status;
}

/**
 * @brief   Returns a series of bytes generated by the RNG.
 *
 * @param[in]  rngp     pointer to the @p RNGDriver object
 * @param[out] buf      pointer to a buffer to fill with random data
 * @param[in]  buf_len  number of bytes to generate
 *
 * @api
 */
void rngGenerate(RNGDriver *rngp, uint8_t* buf, uint32_t buf_len) {
  rng_lld_generate(rngp, buf, buf_len);
}

/**
 * @brief   Returns a random 8-bit value generated by the RNG.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 * @return              A random 8-bit value.
 *
 * @api
 */
uint8_t rngNext8(RNGDriver *rngp) {

  uint8_t val;

  rng_lld_generate(rngp, &val, sizeof(val));

  return val;
}

/**
 * @brief   Returns a random 16-bit value generated by the RNG.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 * @return              A random 16-bit value.
 *
 * @api
 */
uint16_t rngNext16(RNGDriver *rngp) {

  uint16_t val;

  rng_lld_generate(rngp, (uint8_t*)&val, sizeof(val));

  return val;
}

/**
 * @brief   Returns a random 32-bit value generated by the RNG.
 *
 * @param[in] rngp      pointer to the @p RNGDriver object
 * @return              A random 32-bit value.
 *
 * @api
 */
uint32_t rngNext32(RNGDriver *rngp) {

  uint32_t val;

  rng_lld_generate(rngp, (uint8_t*)&val, sizeof(val));

  return val;
}

#endif /* HAL_USE_RNG */

/** @} */
